## Java 제어자
- 클래스, 변수, 메서드, 생성자 등에 추가로 설정하여 대상의 사용방법, 메모리 할당 시기 또는 스코프 등을 결정하는 역할

1. 접근제어자 : public '+', protected '#', () 'default', private '-' / '?'-> 클래스 다이어그램 내 표시 기호
   - 클래스 앞 : `public` or `()`(생략) 둘 중 하나만 가능.
   - 멤버변수, 생성자, 메서드 앞 : `public`, `protected`, `(생략)`, `private`

2. 활용제어자(일반제어자) : static, final, abstract
   - `static` : 멤버변수, 메서드, static 블럭
   - `final` : 클래스, 멤버변수, 지역변수, 메서드
   - `abstract` : 클래스, 메서드

## 상속
```java
class A{
	A(){
		System.out.println("A 클래스 객체 생성");
	}
}

class B extends A{
	B(){
		System.out.println("B 클래스 객체 생성");
	}
}

class C extends B{
	C(){
		System.out.println("C 클래스 객체 생성");
	}
}
// C > B > A > Object class

public class ABCTest {
	public static void main(String[] args) {
		new C(); 
		// C class의 생성자 메서드를 불러옴.
		// C가 처음 생성되면서 차례로 상속된 B(A를 상속), A class 가 호출된다.
		// 상속이 많을수록 메모리 할당 부담이 커진다. <- 많은 부모 객체들도 생성되므로
		// 처리되는 순서 또한 부모 클래스 부터 처리된다.
		// (부모 클래스 로딩이 먼저되어야한다는 규칙이 있다.)
	}
}

```

## 다형성
- '여러 형태를 갖는다.' : 사전적인 의미
- 특정 타입의 변수를 가지고 해당 타입의 객체 뿐만 아니라 다른 타입의 객체도 다룰 수 있는 기능.
- 부모타입의 변수로 자식 객체까지 저장하여 다룰 수 있게 하는 기능.
+) 클래스 타입의 변수는 참조 변수로서, 어떠한 클래스 타입의 변수냐에 따라 접근할 수 있는 멤버들의 사양이 정해진다.
- 참조형 매개변수는 메서드 호출시, **자신과 같은 타입 또는 자손타입** 의 인스턴스를 넘겨줄 수 있다.

<br>

### 메서드 오버로딩
: "하나의 클래스에 같은 이름의 메서드를 여러 개 정의하는 것을 메서드 오버로딩, 간단히 오버로딩이라고 한다."
- 메서드의 이름이 같아야 한다.
- 매개변수의 개수 또는 타입이 달라야 한다.
- 매개변수는 같고 리턴타입이 다른 경우는 오버로딩이 성립되지 않는다.<br>(리턴타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다.)


## `abstract` 클래스, `interface`
- abstract : '추상적인, 미완성의' 사전적 의미
- 클래스 정의 시 설정 가능한 제어자 : `public`, `()`, `final`, **`abstract`**
  
```java
class A          // 상속, 객체 생성 등 자유로운 형태
final class B    // 더 이상 확장X, 상속X, 객체 생성만 가능.
abstract class C // 미완성 클래스, 객체 생성X, 상속만 가능.
```
- `abstract`는 메서드에도 설정 가능한 제어자.
- `abstract` 메서드 : 미완성 메서드, 메서드의 헤더만 정해진 메서드<br>
==> 메서드명, 매개변수, 리턴값 등의 타입 등은 정해졌으나 수행코드가 정해지지 않은 메서드<br>
===> 수행 코드는 자식에서 오버라이딩하게 되는 메서드
```java
abstract void buy(); // => abstract 메서드는 {} 블럭이 아닌 ;이 마지막에 반드시 붙어야한다.

/**
* 클래스에 abstract 메서드가 1개라도 정의된 경우,
* 클래스도 반드시 abstract로 설정해야한다.
**/
```

### `interface` 
: 특별한 자바 클래스 / 상수, 추상메서드, static 메서드, default 메서드
```java
interface 인터페이스명 [extends 부모인터페이스,...]{
	상수, 추상메서드, static 메서드, default 메서드
}
// 인터페이스 내 정의된 추상 메서드의 public 지정은 필수!!

class 클래스명 extends 부모클래스 implements 부모인터페이스1, ~2... {
	// 인터페이스 다중 상속이 가능하다.
	// 다형성이 베이스로 깔려있어 가능한 것.	
}

```

<br>

 ## ➕ `new` 연산자 🚀
- 객체를 Heap이라는 메모리 영역에 메모리 공간을 할당해주고 메모리주소를 반환한 후 생성자를 실행시켜준다.
- `new` 연산자로 생성된 객체는 똑같은 값이라도 **서로 다른 메모리를 할당**하기 때문에 **서로 다른 객체로 분리**된다.
- ### `String str = new String("string");` 작동원리 예시
> 우선 변수는 'Stack' 영역에 할당되고, `new String` 으로 생성된 문자열값이 'Heap' 영역의 메모리 공간을 할당받아<br>
> `str` 이라는 변수가 그 메모리주소를 가르킬 것 입니다. 이를 다른 말로 **참조** 라고도 합니다.<br><br>
> 만약 `String str2 = new String("string");` 와 같은 똑같은 값을 가진 변수가 선언되어 `new` 연산자를 통해 초기화 된다면<br>
> 이는 **똑같이 'Stack' 과 'Heap' 영역의 메모리 공간을 할당받아 저장**될 것 이며, **앞서 선언한 `str` 과는 전혀 다른 변수**임이 나타날 것 입니다.







